---
phase: 14-navigation-maps
plan: 02
type: execute
depends_on: []
files_modified:
  - src/hooks/useMapState.ts
  - src/lib/mapStateUtils.ts
domain: next-js
---

<objective>
Create useMapState hook for bidirectional URL synchronization with map state.

Purpose: Enable deep-linking to specific map views (zoom level, center, selected district) so users can share and bookmark exact map positions.

Output: useMapState hook that syncs map viewport state with URL query parameters.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Key Files:**
@src/app/[state]/page.tsx (existing URL state pattern)
@src/hooks/useLeafletMap.ts
@src/hooks/useReducedMotion.ts

**Tech stack available:**
- Next.js App Router (useSearchParams, useRouter, usePathname)
- Leaflet map instance access via useLeafletMap

**Established patterns:**
- URL state parsing in StateDashboard (`updateUrl` function)
- History replaceState for URL updates without navigation
- Debouncing for performance

**Constraining decisions:**
- Static export (no server-side state)
- Client-side URL state only
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mapStateUtils for URL serialization</name>
  <files>src/lib/mapStateUtils.ts</files>
  <action>
Create utility functions for map state URL serialization:

1. Define MapState interface:
   ```typescript
   interface MapState {
     lat?: number;
     lng?: number;
     zoom?: number;
     chamber?: 'house' | 'senate' | 'congressional';
     district?: number;
   }
   ```

2. Create serializeMapState(state: MapState): URLSearchParams
   - Only include non-null/non-default values
   - Round lat/lng to 4 decimal places for reasonable precision
   - Example output: `?lat=33.8361&lng=-81.1637&zoom=10&chamber=house&district=42`

3. Create parseMapState(params: URLSearchParams): MapState
   - Parse and validate each parameter
   - Return defaults for missing values
   - Handle invalid values gracefully (return default)

4. Define defaults:
   - SC center: lat=33.8361, lng=-80.9450
   - Default zoom: 7 (state view)
   - Default chamber: 'house'
   - Default district: null

5. Export all types and functions.

Avoid: Over-engineering with complex state machines.
Why: This is a simple serialization layer, not a state management solution.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>mapStateUtils.ts exports MapState type, serializeMapState, parseMapState functions</done>
</task>

<task type="auto">
  <name>Task 2: Create useMapState hook</name>
  <files>src/hooks/useMapState.ts</files>
  <action>
Create useMapState hook for bidirectional URL sync:

1. Hook signature:
   ```typescript
   function useMapState(options?: {
     debounceMs?: number;
     syncOnMount?: boolean;
   }): {
     mapState: MapState;
     setMapState: (state: Partial<MapState>) => void;
     updateFromMap: (map: LeafletMap) => void;
     applyToMap: (map: LeafletMap) => void;
   }
   ```

2. Initialize from URL on mount:
   - Parse current URL search params
   - Return parsed state via mapState

3. Sync to URL on state changes:
   - Use window.history.replaceState (not pushState to avoid history spam)
   - Debounce updates (default 300ms) to prevent URL thrashing during pan/zoom
   - Preserve existing non-map params in URL

4. Provide map integration helpers:
   - updateFromMap: Extract state from Leaflet map instance
   - applyToMap: Apply state to Leaflet map (flyTo with animation)

5. Handle SSR safely:
   - Return defaults during SSR
   - Only read/write URL on client

Avoid: Using useSearchParams from Next.js in static export (causes hydration issues).
Why: Static export requires client-only URL reading via window.location.
  </action>
  <verify>
Create a simple test component:
```tsx
const { mapState, setMapState } = useMapState();
console.log(mapState);
```
Verify URL updates when calling setMapState.
  </verify>
  <done>useMapState hook created with URL sync, debouncing, and map integration helpers</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npx tsc --noEmit` passes
- [ ] mapStateUtils correctly serializes/parses map state
- [ ] useMapState reads initial state from URL
- [ ] useMapState updates URL on state changes
- [ ] Debouncing prevents URL thrashing
- [ ] SSR-safe (no window errors during build)
</verification>

<success_criteria>
- mapStateUtils.ts exports working serialization functions
- useMapState hook provides bidirectional URL sync
- No build errors or hydration issues
- Ready for integration in Plan 03
</success_criteria>

<output>
After completion, create `.planning/phases/14-navigation-maps/14-02-SUMMARY.md` following the summary template.
</output>
