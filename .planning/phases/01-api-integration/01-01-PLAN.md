---
phase: 01-api-integration
plan: 01
type: execute
depends_on: []
files_modified: [src/lib/ballotready.ts, src/lib/targetsmart.ts, src/lib/voterIntelligence.ts]
---

<objective>
Verify and harden the BallotReady and TargetSmart API integration layer.

Purpose: The API clients exist but have not been tested against live APIs. This plan verifies functionality, hardens error handling, and ensures the integration layer is production-ready.

Output: Verified, tested API integration layer ready for consumption by subsequent phases.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/ballotready.ts
@src/lib/targetsmart.ts
@src/lib/voterIntelligence.ts
@src/types/ballotready.d.ts
@src/types/targetsmart.d.ts

**Already Complete:**
- API clients with caching and rate limiting (ballotready.ts, targetsmart.ts)
- Aggregation utilities (voterIntelligence.ts)
- Complete TypeScript type definitions
- .env.local with API keys configured
- Build passes with current code

**This Plan Focuses On:**
- Verifying API calls work with actual credentials
- Hardening error handling for API failures
- Adding graceful degradation when APIs unavailable
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API verification script</name>
  <files>scripts/verify-apis.ts</files>
  <action>Create a Node.js script that tests both API clients against live endpoints:

  1. Test BallotReady API:
     - `getElections('SC')` - Should return array of elections
     - `getNextElection('SC')` - Should return election object with election_day
     - `getPositions({ state: 'SC', level: 'state' })` - Should return positions

  2. Test TargetSmart API:
     - `isConfigured()` - Should return true
     - Test with a sample SC address for district lookup

  3. Handle and report errors clearly:
     - API key missing → "Missing API key"
     - 401/403 → "Invalid API key or access denied"
     - Network error → "API unreachable"
     - Success → "API verified"

  4. Output structured JSON result:
     ```json
     {
       "ballotready": { "status": "success|error", "message": "...", "sampleData": {...} },
       "targetsmart": { "status": "success|error", "message": "...", "sampleData": {...} }
     }
     ```

  Script must be runnable via `npx tsx scripts/verify-apis.ts`</action>
  <verify>npx tsx scripts/verify-apis.ts runs without error and outputs JSON result</verify>
  <done>Script exists, is executable, and produces structured verification output</done>
</task>

<task type="auto">
  <name>Task 2: Harden API client error handling</name>
  <files>src/lib/ballotready.ts, src/lib/targetsmart.ts</files>
  <action>Improve error handling in both API clients:

  1. In ballotready.ts `apiRequest()`:
     - Add try/catch wrapper around fetch
     - Handle network errors (TypeError from fetch) with specific message
     - Add timeout handling (abort after 10 seconds)
     - Log errors to console with context but don't expose to user
     - Return null or empty array instead of throwing for non-critical calls

  2. In targetsmart.ts `apiRequest()`:
     - Same improvements as ballotready.ts
     - Ensure mock data fallback works correctly when API unavailable

  3. Add `testConnection()` function to both clients:
     ```typescript
     export async function testConnection(): Promise<{ ok: boolean; error?: string }> {
       // Make minimal API call to verify connectivity
     }
     ```

  4. DO NOT change function signatures or return types for existing exported functions - maintain backward compatibility.</action>
  <verify>npm run build passes with no errors</verify>
  <done>Both clients have hardened error handling with timeout, network error handling, and testConnection() function</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>API verification script and hardened error handling</what-built>
  <how-to-verify>
    1. Run verification script: `npx tsx scripts/verify-apis.ts`
    2. Check output shows status for both APIs
    3. If APIs return errors, the script should show helpful error messages (not stack traces)
    4. Verify dev server works: `npm run dev` (check localhost:3000 loads)
  </how-to-verify>
  <resume-signal>Type "approved" if verification passes, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `scripts/verify-apis.ts` exists and runs without error
- [ ] Both API clients have `testConnection()` function
- [ ] Error handling includes timeout and network error handling
- [ ] API clients don't crash app when APIs are unavailable
</verification>

<success_criteria>

- API verification script runs and outputs structured results
- Both API clients have hardened error handling
- Build passes with all changes
- Human verification confirms APIs work or shows clear error messages
</success_criteria>

<output>
After completion, create `.planning/phases/01-api-integration/01-01-SUMMARY.md`:

# Phase 1 Plan 1: API Verification Summary

**[Brief summary of what was accomplished]**

## Accomplishments

- [List key outcomes]

## Files Created/Modified

- `scripts/verify-apis.ts` - API verification script
- `src/lib/ballotready.ts` - Hardened error handling
- `src/lib/targetsmart.ts` - Hardened error handling

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for Phase 1 Plan 2 or Phase 2 (Election Timeline)
</output>
